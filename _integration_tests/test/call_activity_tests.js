'use strict';

const should = require('should');
const uuid = require('node-uuid');

const {ProcessInstanceHandler, TestFixtureProvider} = require('../dist/commonjs');

describe('Call activity tests', () => {

  let processInstanceHandler;
  let testFixtureProvider;

  const startEventId = 'StartEvent_1';
  const useAutoGeneratedCorrelationId = undefined;

  let finishedCorrelationId;

  before(async () => {
    testFixtureProvider = new TestFixtureProvider();
    await testFixtureProvider.initializeAndStart();

    const processDefFileList = [
      'call_activity_subprocess',
      'call_activity_subprocess_error',
      'call_activity_subprocess_nested',
      'call_activity_test',
      'call_activity_test_error',
    ];

    await testFixtureProvider.importProcessFiles(processDefFileList);
    processInstanceHandler = new ProcessInstanceHandler(testFixtureProvider);
  });

  after(async () => {
    await testFixtureProvider.tearDown();
  });

  it('should execute a process which runs a Subprocess through a CallActivity', async () => {
    const processModelId = 'call_activity_test';

    const initialToken = {
      operation: 'basic_test',
    };

    let finalResult;

    const correlationId = uuid.v4();

    await new Promise(async (resolve, reject) => {
      const startResult = await processInstanceHandler.startProcessInstanceAndReturnResult(processModelId, correlationId, initialToken);

      processInstanceHandler.waitForProcessWithInstanceIdToEnd(startResult.processInstanceId, (message) => {
        finalResult = message.currentToken;
        resolve();
      });
    });

    finishedCorrelationId = correlationId;

    should(finalResult).have.property('history');
    should(finalResult).have.property('current');

    const task1Result = finalResult.history.Task1;
    const processResult = finalResult.current;

    should(task1Result).be.eql(1, `Expected a value of 1 to be passed to the subprocess, but instead got ${task1Result}`);
    should(processResult).be.eql(2, `Expected a subprocess result of 2, but instead got ${finalResult}`);
  });

  it('should ensure that all ProcessInstances in the previously run Correlation have been set to a finished state', async () => {

    const correlationRepository = await testFixtureProvider.resolveAsync('CorrelationRepository');

    const entries = await correlationRepository.getByCorrelationId(finishedCorrelationId);

    should(entries.length).be.equal(2);

    for (const entry of entries) {
      const assertionErrorMessage = `ProcessInstance ${entry.processInstanceId} in Correlation ${finishedCorrelationId} was not finished!`;
      should(entry.state).be.equal('finished', assertionErrorMessage);
    }
  });

  it('should execute a process which uses two nested CallActivities to increment a given token', async () => {
    const processModelId = 'call_activity_test';

    const initialToken = {
      operation: 'nested_test',
    };

    const result = await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);

    should(result).have.property('currentToken');
    should(result.currentToken).have.property('history');
    should(result.currentToken).have.property('current');

    const task1Result = result.currentToken.history.Task1;
    const finalResult = result.currentToken.current;

    should(task1Result).be.eql(1, `Expected a value of 1 to be passed to the nested subprocess, but instead got ${task1Result}`);
    should(finalResult).be.eql(3, `Expected a subprocess result of 3, but instead got ${finalResult}`);
  });

  it('should call an erroneous CallActivity, whose error will be handled by the CallActivity itself', async () => {
    const processModelId = 'call_activity_test_error';

    const initialToken = {
      handle_exception: true,
    };

    const result = await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);

    should(result).have.property('currentToken');
    should(result.currentToken).have.property('current');
    should(result.currentToken.current).be.match(/error caught by subprocess/i);
  });

  it('should call an erroneous CallActivity, whose error will be handled by a boundary event in the calling process', async () => {
    const processModelId = 'call_activity_test_error';

    const initialToken = {
      handle_exception: false,
    };

    const result = await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);

    should(result).have.property('currentToken');
    should(result.currentToken).have.property('current');
    should(result.currentToken.current).be.match(/error caught by main process/i);
  });
});
