'use strict';
const should = require('should');
const TestFixtureProvider = require('../dist/commonjs').TestFixtureProvider;

describe('Service Task - ', () => {

  let testFixtureProvider;

  const processModelId = 'service_task_test';
  const processModelExternalTaskId = 'service_task_external_test';
  const startEventId = 'StartEvent_1';
  const useAutoGeneratedCorrelationId = undefined;

  before(async () => {
    testFixtureProvider = new TestFixtureProvider();
    await testFixtureProvider.initializeAndStart();

    await testFixtureProvider.importProcessFiles([processModelId, processModelExternalTaskId]);
  });

  after(async () => {
    await testFixtureProvider.tearDown();
  });

  it('should sucessfully perform a series of ServiceTasks that use a method invocation', async () => {

    const initialToken = {
      test_type: 'method_invocation',
    };

    const simpleObject = {
      prop1: 1337,
      prop2: 'Hello World',
    };

    const result = await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);

    should(result).have.property('currentToken');
    should(result.currentToken).be.eql(simpleObject);
  });

  it('should successfully skip a ServiceTask that has no invocation specified', async () => {

    const initialToken = {
      test_type: 'empty_invocation',
    };

    const expectedResult = /empty.*?successfully run/i;

    const result = await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);

    should(result).have.property('currentToken');
    should(result.currentToken).be.match(expectedResult);
  });

  it('should successfully skip a ServiceTask that has unsupported extension properties attached to it', async () => {

    const initialToken = {
      test_type: 'unsupported_invocation',
    };

    const expectedResult = /unsupported.*?successfully run/i;

    const result = await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);

    should(result).have.property('currentToken');
    should(result.currentToken).be.match(expectedResult);
  });

  it('should sucessfully execute an external ServiceTask via the ExternalTask API', async () => {

    const initialToken = {
      test_type: 'normal',
    };

    const result = await testFixtureProvider.executeProcess(processModelExternalTaskId, startEventId, useAutoGeneratedCorrelationId, initialToken);

    should(result).have.property('currentToken');
    should(result.currentToken).have.property('testResults');
  });

  it('should fail to execute a MethodInvocation on an external ServiceTask', async () => {

    const initialToken = {
      test_type: 'misconfigured_external',
    };

    const expectedErrorMessage = /cannot perform methodinvocations/i;

    try {
      await testFixtureProvider.executeProcess(processModelExternalTaskId, startEventId, useAutoGeneratedCorrelationId, initialToken);
    } catch (error) {
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should fail to execute an ExternalTaskInvocation on an internal ServiceTask', async () => {

    const initialToken = {
      test_type: 'misconfigured_internal',
    };

    const expectedErrorMessage = /must use methodinvocations/i;

    try {
      await testFixtureProvider.executeProcess(processModelExternalTaskId, startEventId, useAutoGeneratedCorrelationId, initialToken);
    } catch (error) {
      should(error.message).be.match(expectedErrorMessage);
    }
  });

  it('should fail to execute a ServiceTask, whose invocation exits with an Error', async () => {

    const initialToken = {
      test_type: 'throw_exception',
    };

    const expectedErrorMessage = /failed/i;

    try {
      await testFixtureProvider.executeProcess(processModelId, startEventId, useAutoGeneratedCorrelationId, initialToken);
    } catch (error) {
      should(error.message).be.match(expectedErrorMessage);
    }
  });
});
